# -*- coding: utf-8 -*-
"""Data Mining PS6 - 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16Jb6iBJzQVFIHFZSjpturMhdXTAlL32G

#Question - 1
"""

import pandas as pd

from itertools import combinations

#Fill NA with zeroes
df = pd.read_csv('transaction1.csv',header=None)
df = df.fillna(0)
transactions = df.values.tolist()

#Remove the zeroes from the transaction
for i in range(0,len(transactions)):
  while 0 in transactions[i]:
    transactions[i].remove(0)

#Print the transactions
transactions

N1 = len(transactions)

#Set the minimum support to 3
s = 0.3

#Function to generate the Candidate 1-itemset
def candidate_1_itemset():
  candidates.append({})
  #Mapping the items with their values
  for l in transactions:
    for x in l:
      if x in candidates[0]:
        candidates[0][x] += 1
      else:
        candidates[0][x] = 1
  print(candidates[0])

#Function to generate the Candidate 2-itemset
def candidate_2_itemset():
  #Generate all combinations.
  c2=list(combinations(frequentItemSets[0],2))
  candidates.append({})
  #Assign 0 to all possible combinations initially.
  for x in c2:
    candidates[1][x]=0
  for subset in candidates[1]:
    for i in range(0,len(transactions)):
      #For each combination check if it is present in any of the transactions.
      #If yes, increment the count of that combination.
      if set(subset).issubset(set(transactions[i])):
        candidates[1][subset]+=1
  print(candidates[1])

#Function to generate frequent itemset from the candidate set.
def frequentItemSetGeneration(C):
  L = [x for x in C if (C[x]/N1)>=s]
  #Sort is done to maintain the lexicographic order.
  L.sort()
  return L

#Function to generate candidate itemset from the previous frequent itemset.
def candidateSetGeneration(L):
  C = {}
  for i in range(0,len(L)):
    for j in range(i+1,len(L)):
      #Check if the first few items of the combination is same.
      if L[i][0:len(L[i])-1] == L[j][0:len(L[j])-1]:
        #Join the items
        string = set(list(L[i]) + list(L[j]))
        #Generate possible subsets for the pruning step.
        sets = combinations(string,len(L[i]))
        flag = 0
        for each in sets:
          lis = list(each)
          lis.sort()
          #If any of the subset is not present in L, then that particular set should be pruned.
          if tuple(lis) not in L:
            flag=1
            break
        #If the set is not pruned, add it to the candidate set with count 0.
        if flag == 0:
          string = list(string)
          string.sort()
          C[tuple(string)]=0
  #For each subset check if it is present in any of the transactions.
  #If yes, increment the count of that subset.
  for subset in C:
    for i in range(0,len(transactions)):
      if set(subset).issubset(set(transactions[i])):
        C[subset]+=1
  return C

#candidates store all possible candidate itemsets along with the support count.
#Each k-item candidate set is a dictionary.
candidates = []
#frequentItemSets store the frequent itemsets.
#Each k-item frequent set is a list.
frequentItemSets = []

#Candidate 1-itemset generation:
print('Candidate 1-itemset:')
candidate_1_itemset()

#Frequent 1-itemset:
print('Frequent 1-itemset:')
frequentItemSets.append(frequentItemSetGeneration(candidates[0]))
print(frequentItemSets[0])

#Candidate 2-itemset:
print('Candidate 2-itemset:')
candidate_2_itemset()

#Frequent 2-itemset:
print('Frequent 2-itemset:')
frequentItemSets.append(frequentItemSetGeneration(candidates[1]))
print(frequentItemSets[1])

#Generating k-itemsets where k starts from 3.
flag = True
i = 0
while flag:
  i = i+1
  #Start from finding candidate 3-itemset and frequent 3-itemset until frequent itemset becomes [].
  print('Candidate ',i+2,'-itemset:')
  candidates.append(candidateSetGeneration(frequentItemSets[i]))
  print(candidates[i+1])
  print('Frequent ',i+2,'-itemset:')
  freq = frequentItemSetGeneration(candidates[i+1])
  #When frquent itemset becomes [], exit from the loop. So, set flag = false.
  if freq == []:
    flag = False
  frequentItemSets.append(freq)
  print(frequentItemSets[i+1])

#Frequent Item Sets:
f=open("Frequent Item Sets.txt","w")
for i in range(0,len(frequentItemSets)):
    f.write("%s => %s\n" %('L'+str(i+1) ,str(frequentItemSets[i])))
       
f.close()   
print(frequentItemSets)

def association(Total_candidate,L,C,conf):
    A={}
    for i in L:
         for j in range(1,len(i)):
             for combination in combinations(i,j):
                 s=set(combination)
                 l=set(i)
                 subset2=l.difference(s)
                 l_s=tuple(sorted(subset2))
                 if len(l_s)==1:
                    l_s=l_s[0]
                 A[tuple(s),l_s]=C[i]/Total_candidate[l_s]  
                 if A[tuple(s),l_s]<conf:
                      del A[tuple(s),l_s]
    for i in A:
      print(i[0],"=>",i[1],":",A[i])
     
    return A

conf=0.7  
#association rules
C = {}
for i in range(0,len(candidates)):
  C.update(candidates[i])
A={}
for i in range(1,len(candidates)):
  A.update(association(C,frequentItemSets[i],candidates[i],conf))

f=open("Association Rules.txt","w")
for rule in A:
    f.write("%s => %s : %f\n" %(str(rule[0]) ,str(rule[1]),A[rule]))
       
f.close()
